
## 内存

mmu以页为单位管理内存 页是描述物理页的

区 系统中会把内存分区 dma normal highmem 不过x64中只有dma和normal 



有获取页的函数和释放页的函数

也有获取字节的函数 kmalloc



获取页和字节内存的时候 可以有行为描述符和状态描述符

其中类型标准是行为描述符和状态描述符的结合



vmalloc和kmalloc类似只不过vmalloc分配的只保证虚拟地址连续。

大多数情况只有物理设备需要连续的物理地址。软件内存都可以使用虚拟地址，但是实际上内核代码大部分使用的都是kmalloc，除非需要分配大块内存的时候。因为他们物理上是不连续的，所以要把他们不连续的页一个个进行映射。



## 虚拟内存结构体

- task_struct
  - mm_struct
    - vm_area_struct 链表，存储着栈，映射区，堆，bss段，数据段，代码段。
    - rb_root 红黑数，存的也是 vm_area_struct

## 物理内存模型

内核以页为基本单位对物理内存进行管理。用 strcut page 结构来进行管理。

- struct page
  - 组织结构
  - 使用信息
  - 统计信息
  - 映射信息等

此外还定义了一个索引编号 PFN 与 page 一一对应。

### 平坦内存模型

物理内存是一块连续的储存空间，物理地址是连续的，划分的页也是连续的。用page数组来组织这些页，然后数组下标即为PFN

linux 早起使用的就是这种内存模型

### 非连续内存模型

将物理内存分为了一个个node，每个node下管理一块连着的页。相当于每个node是平坦内存模型。但是node和node之间的物理内存不要求连续。

### 稀疏内存模型

对粒度更小的连续内存块做精细的管理，管理连续内存块的单元叫section，物理页大小为4k的话，一个section有 2^20 个页。
所有的 section 结构体放在一个全局的数组中。并且有online/offline。以便支持内存热插拔。

## CPU角度物理内存架构

CPU访问内存是要经过总线的。

### UMA 一致性内存访问

总线一侧是内存，另一侧是CPU，所有的CPU访问内存的。所有的 CPU对内存的访问距离都是一样的。

### NUMA 非一致性内存访问

内存不再是一整块，而是分成了一个个内存节点，每个CPU都有自己的内存节点，访问自己的内存节点时不需要经过总线。跨节点访问的时候需要经过总线。

NUMA 架构下，物理内存被划分了一个个NUMA节点，每个NUMA节点又被划为几个内存区域。

Node->Zone->Page

内核会为每一个内存区域分配一个伙伴系统，用于管理页面的分配和释放


### 物理内存页

文件页
匿名页， swap

内存水位线

sudo usermod -Ga $USER docker









